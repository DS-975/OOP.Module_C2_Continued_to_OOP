# C2.6. Исключения

# Предположим, мы написали программу. Она вроде даже запустилась и вроде
# даже что-то сделала. Но «в один прекрасный момент» всё вылетело, а в
# терминале появилось непонятное сообщение по типу:

Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: "odin"

# Эта ошибка относится к типу исключительных ситуаций.
# Такие ситуации возникают, когда вы — большой молодец, написали
# код правильно. Он запустился и отработал своё. На следующий день
# вы решили запустить код повторно. Что же вы видите? Ошибка! Но как?
# В прошлый раз всё ведь запускалось без ошибок. Почему? Дело в том,
# что исключения могут возникнуть не только из-за ошибок в написании
# кода, а ещё из-за:

# * взаимодействия пользователя с вашей программой;

# * состояния системы, на которой программа запущена;

# * погоды или расположения Луны в Юпитере.

# В общем, от чего угодно, но только не от вашего кода. Да-да,
# сегодня вы узнаете, как работать с исключительными ситуациями
# или же «исключениями» в языке Python.

# Исключения – это ошибки, которые возникают не во время компиляции
#              программы, а в процессе её исполнения, в случаях,
#              если что-то идёт не так.

# После возникновения исключения программа попытается экстренно
# завершить работу или перейти к обработчику исключения, если такой есть.
# Python — интерпретируемый язык, поэтому исключения и вставляют нам
# чаще всего палки в колёса, прерывая выполнение программы.

# Ошибки бывают двух видов:

# 1 Неотлавливаемые — SystemExit, KeyboardInterrupt (существуют на уровне
#                     ОС и внутренностей Python, поэтому из
#                     кода не видны) и т.д.

# 2 Отлавливаемые — всё, что наследуются от класса Exception
#                   (более подробно поговорим в одном из следующих уроков).

# Заучивать их все не стоит, только зря потратите время, потому
# что этих ошибок может быть множество. Например, в отдельной
# библиотеке есть собственные исключения (писать собственные
# исключения мы научимся на следующем занятии).

# Давайте посмотрим на пример кода, который вызывает исключение.

# -------------------------------------------------------------------------
# |   Название исключения   |   Когда возникает   |   Название в Python   |
# |-------------------------|---------------------|-----------------------|
# | Исключение, возникающее | При делении на ноль |	  ZeroDivisionError   |
# | при делении на 0        |                     |                       |
# |-------------------------|---------------------|-----------------------|
# |                         | При невозможности   |                       |
# |     Ошибка значения     | привести один тип   |      ValueError       |
# |                         | к другому           |                       |
# |-------------------------|---------------------|-----------------------|
# |                         | Если попытаться     |                       |
# |     Файл не найден      | открыть файл для    |   FileNotFoundError   |
# |                         | чтения, который     |                       |
# |                         | не был создан       |                       |
# |-------------------------|---------------------|-----------------------|
# |                         | Если попытаться     |                       |
# |                         | открыть файл из  	  |                       |
# |    Недостаточно прав    | корневых каталогов  |    PermissionError    |
# |                         | при запуске         |                       |
# |                         | программы не от     |                       |
# |                         | имени администратора|                       |
# -------------------------------------------------------------------------

# Это лишь несколько из них. Список всех исключений доступен в
# документации Python. Можете ознакомиться с ним, чтобы быть в
# курсе того, какие ошибки могут возникнуть в простых программах.

print("Перед исключением")
I = 1 / 0 # Здесь что-то не так….
print("После исключения")

# В консоли мы увидим результат:

# Перед исключением
# Traceback (most recent call last):
# File "<stdin>", line 1, in <module>
# ZeroDivisionError: division by zero

# Строка «После исключения» не будет выведена на экран, потому что,
# как только интерпретатор дойдёт до строчки I = 1 / 0, он экстренно
# завершит работу и выведет нам сообщение об ошибке деления на ноль.

# В этом примере мы чётко видим, что может возникнуть ошибка.
# Но в большинстве случаев это бывает не очень очевидно.
# Поэтому давайте слегка поменяем наш код:

print("Перед исключением")
# теперь пользователь сам вводит числа для деления
a = int(input("a: "))
b = int(input("b: "))
c = a / b # здесь может возникнуть исключение деления на ноль
print(c) # печатаем c = a / b, если всё хорошо
print(e) # Выводим информацию об ошибке
print("После исключения")

# После выполнения этого кода у пользователя может возникнуть такая
# же ошибка, если он введёт b = 0.

# Как же сделать так, чтобы программа не вылетала при ошибке и
# продолжала свою работу?

# Очень просто :) Для этого нужна конструкция try-except.
# Давайте посмотрим на следующий код:

try:  # Добавляем конструкцию try-except для отлова нашей ошибки
    print("Перед исключением")
    # теперь пользователь сам вводит числа для деления
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b  # здесь может возникнуть исключение деления на ноль
    print(c)  # печатаем c = a / b, если всё хорошо
except ZeroDivisionError as e:  # Добавляем тип именно той ошибки, которую хотим отловить.
    print(e)  # Выводим информацию об ошибке
    print("После исключения")

print("После исключения")

# В данном случае тоже может возникнуть ошибка деления на ноль,
# если пользователь введёт b = 0. Поэтому мы отлавливаем ошибку
# ZeroDivisionError.

# В блок try помещается «опасный» кусок кода, который может
# вызывать исключения. В блоке except указывается класс ошибки,
# которую мы хотим отловить. Затем помещается код, который
# нужно выполнить в случае возникновении ошибки.
# После возникновения ошибки код в блоке try прервётся,
# перейдёт в блок except, а затем продолжит выполняться дальше,
# т.е. программа не вылетает, как это было без обработчика исключений.
# В этом и есть смысл конструкции try-except.

# Что значит "as e"? Это означает, что программа отлавливает
# исключения типа BoardException, и то исключение, которое
# возникло в блоке except: (сам объект, а не класс исключения),
# будет привязано к переменной e.

# Finally и else

# Конечно же, это ещё не всё. Есть блоки finally и else.
# Если вы хорошо помните тему условий, то там тоже было
# ключевое слово else.

# С try-except есть нечто похожее. Посмотрите на пример кода ниже.



try:
    *ваш код*
except Ошибка:
    *Код отлова*

else:
    *Код, который выполнится, если в блоке try всё хорошо прошло*
finally:
    *Код, который выполнится по-любому*

# Важно обратить внимание на отступы. Код внутри конструкции сдвинут
# на второй уровень вложенности. Рассмотрим применение этих блоков
# на примере:

try:
    print("Перед исключением")
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b
    print(c)  # печатаем c = a / b, если всё хорошо
except ZeroDivisionError as e:
    print("После исключения")
else:  # код в блоке else выполняется только в том случае, если код в блоке try выполнился успешно (т.е. не вылетело никакого исключения).
    print("Всё отлично")
finally:  # код в блоке finally выполнится в любом случае, при выходе из try-except
    print("Finally на месте")

print("После исключения")

# Здесь результат работы программы будет зависеть от ввода
# пользователя. Если пользователь введёт всё правильно,
# то он должен увидеть следующее:

# Перед исключением
# *результат деления a/b*
# Всё отлично
# Finally на месте
# После исключения

# Если же ошибка возникнет, то пользователь увидит следующее:

# Перед исключением
# После исключения
# Finally на месте
# После исключения

# Т.е. код в блоке else не выполнится, т.к. было исключение,
# а код в блоке finally выполняется в обоих случаях.

# Raise

# И конечно же, мы можем вызывать ошибки самостоятельно,
# с помощью конструкции raise. Используется это, как правило,
# для отладки кода и остановки программы в критических ситуациях.
# Например:

age = int(input("How old are you?"))

if age > 100 or age <= 0:
    raise ValueError("Тебе не может быть столько лет")

print(f"Тебе {age} лет!")  # Возраст выводится, только если пользователь
                           # ввёл правильный возраст.

# Здесь ошибка ValueError возникнет, если пользователь
# ввёл неправильный возраст, и остановит работу программы
# выдав в консоль:

raise ValueError("You are too old or don’t exist")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: You are too old or don"t exist

# В консоль выводится именно то сообщение, которое вы передадите
# в аргумент конструктора класса вашего исключения. Если не
# хотите выводить никаких сообщений, то просто оставьте скобки пустыми.

# Стоит отметить, что отлавливать вызываемые с помощью raise
# ошибки тоже можно. Например:

try:
    age = int(input("How old are you?"))

    if age > 100 or age <= 0:
        raise ValueError("Тебе не может быть столько лет")
except ValueError:
    print("Неправильный возраст")

print(f"You are {age} years old!")  # Возраст выводится,
                                    # только если пользователь
                                    # ввёл правильный возраст.

# Подведём итоги:

# 1. Исключения — это ошибки, которые выбрасываются при
#    неправильной работе программы и останавливают её
#    выполнение, если они не обработаны.

# 2. Конструкция try-except служит для обработки исключений
#    и выглядит следующим образом:

# try:
#     *код, который может вызвать ту или иную ошибку*
# except *ошибка*:
#     *код, который выполнится в случае возникновения ошибки*
# else:
#     *код, который выполнится только в случае, если в try ничего не сломалось*
# finally:
#     *код, который выполнится по-любому*

# 3. Блоки finally и else, являются не обязательными, но могут
#    быть использованы для вашего удобства.
#    Код из блока finally выполняется в любом случае,
#    независимо от исхода в блоках try-except.
#    Код из блока else выполняется только в случае успешного
#    выполнения кода в try.

# 4. Выбрасывать ошибки можно и по своему желанию с помощью
#    конструкции raise *Тип ошибки* (сообщение, которое нужно
#    вывести в консоль).

# 2.6.1

# Просмотрите основные виды встроенных исключений в документации.

# Найдите исключение которое, возникает при проблемах с оперативной памятью.

# MemoryError

# 2.6.2

# Исключения — это...

# Ошибки, возникающие в результате работы программы и всегда
# приводящие к её завершению.

# Ошибки, возникающие в результате выполнения программы и
# завершающие её работу, если не предусмотрен их отлов. +++

# Особая сущность в языке Python, которая останавливает
# работу программы в любом месте.

# 2.6.3

# Для отлова исключений используется конструкция...

# try-except

# 2.6.4

# В блоке try помещается...

# Безопасный код, который не вызывает исключений

# Код, который обязательно вызывает хотя бы одно исключение

# Любой код, который может либо вызвать, либо не вызвать исключение. +++

# 2.6.5

# В блоке except должен находиться...

# Безопасный код.

# Код, который вызывает исключения.

# Любой код, который выполнится после возникновения той или иной ошибки. +++

# Код, который выполнится после блока try.

# 2.6.6

# Сопоставьте вариант выполнения с соответствующим блоком.

# 1. Выполняется в любом случае после выхода из try-except:
#    finally

# 2. Выполняется только при удачном завершении кода в блоке try:
#    else

# 2.6.7

# Задание на самопроверку

# * Создайте скрипт, который будет в input() принимать строки и их необходимо будет конвертировать в числа.

# * Добавьте try-except на то, чтобы строки могли быть конвертированы в числа. В случае удачного выполнения скрипта должно быть выведено сообщение: «Вы ввели правильное число».

# * В конце скрипта обязательно напишите: «Выход из программы».

# Примечание: для отлова ошибок используйте try-except, а также блоки finally и else.

# Примеры входов и выходов:

# Введите число:  1
# Вы ввели 1
# Мы на выходе
#
# Введите число:  -3
# Вы ввели -3
# Мы на выходе
#
# Введите число:  razdvatri
# Вы ввели неправильное число
# Мы на выходе

#помещаем код, который может генерировать исключения в блок try
try:
    i = int(input('Введите число:\t'))
#в случае возникновения исключения ValueError выведем соответствующий текст
except ValueError as e:
    print('Вы ввели неправильное число')
#если исключения ValueError не будет то выведем текст, что все в порядке
else:
    print(f'Вы ввели {i}')
#в любом случае, независимо от наличия/отсутствия исключений выполним код
finally:
    print('Мы на выходе')