#С2.3 Работа над архитектурой программы с использование ООП. 
#Создание классов

#В этом юните поговорим о том, как подходить к разбиению стоящей перед
#нами задачи на подзадачи, а также коснёмся вопроса архитектуры
#программы и того, как она может быть выражена в классах.

#Перед тем как переходить непосредственно к классам, ещё нужно немного
#поговорить об архитектуре. Сраним два сооружения: наспех сделанный 
#шалаш и главное здание МГУ. Глядя на шалаш, мы врят ли причислим его к
#архитнктурным объектам, чего не скажешь про высоту МГУ. Почему так?

#Давайье сраним:

# ---------------------------------------------------------------------------------
# |                  Шалаш                 |               Архитектура            |
# |-------------------------------------------------------------------------------|
# |               сооружение               |              сооружение              |
# |-------------------------------------------------------------------------------|
# |        предназначенно для людей        |       предназначенно для людей       |
# |-------------------------------------------------------------------------------|
# |          использованы различные        |        использованы различные        |
# |          строительные материалы        |        строительные материалы        |
# |-------------------------------------------------------------------------------|
# |                 простое                |                сложное               |
# |-------------------------------------------------------------------------------|
# |           временная постройка          |       постройка, предназначеная      |
# |                                        |          на длительное  время        |
# |-------------------------------------------------------------------------------|
# |             Предназначено              |                                      |
# |              для решение               |            предназначенн для         |
# |          ситуационной задачи           |          широкого круга задач        |
# |          (на время укрыться            |                                      |
# |               от дождя)                |                                      |
# |-------------------------------------------------------------------------------|
# |          не имеет и не требует         |        стиль является одной из       |
# |                 стиля                  |          отличительных черт          |
# ---------------------------------------------------------------------------------

# Шалаш нужен для решения маленькой текущей задачи и не предполагает
# наличия какой-то идеи. Его вполне можно назвать "времянкой". Здание же
# МГУ, наоборот, выполняет не только широкий набор функций, но также
# является символом - воплощением определенной идеи, которая получает
# выражение в камне, коммуникациях, работе инженеров и пр. Поэтому,
# когда мы говорим, о главном здании МГУ мф говорим об архитектуре, а
# когда говорим о шалаше - об архитектуре речи не идёт. Похожим образом
# это проявляется и в работе программиста. Когда програмист пытается
# решить ситуацонну задачу и "лишь бы сделать", это приводит к
# появлению "шалашей" в коде. Когда программист пытается решить задачу
# так, чтобы поставить каждый элемент на правильное, предназначенное
# для него, место, он возводит задание.

# Как же понять как поставить всё на своё место ? Существует два
# возможных подхода:

# ---------------------------------------------------------------------------------
# | ↑ "Снизу - верх" - когда мы         | ↓ "Сверху - вниз" - когда мы            |
# |   строим низкоуровневые             |      декомпозируем задачу, пытаемся     |
# |   элементы (ыункции, классы,        |      определить составные элементы,     |
# |   методы), а потом из них пытаемся  |      которые нам нужны для её           |
# |   собрать то, что нам нужно         |     решения, и уже после этого          |
# |                                     |     производим их.                      |
# |   Например, сначала делаем          |                                         |
# |   вентики, гайки и детали, а потом  | В этом случае мы сначала думаем         |
# |   пытаемся из них собрать, скажем   | о тракторе м частях из которых          |
# |   трактор.                          | он состоит, определяемся с тем,         |
# |                                     | какие нужны винтики и в каком           |
# |                                     | количестве, и только после этого        |
# |                                     | берёмся за дело                         |
# ---------------------------------------------------------------------------------


# В современной прикладной разработке чаще всего склоняются ко второму. ↓

# Дело в том, что обычно мы пишем программы "для жизни", а не в отрыве
# от неё. При помощи компьютера мы производим вычисления, которые
# связаны с миром вокруг нас. Первый шаг н пути к написанию программы
# - формализация реально существующего явления в виде логико - 
# математической модели. Звучит страшнее, чем на самом деле :)

# Представьте, что вы вышли с товарищем на встречу друг другу и вам нужно
# прикинуть, через какое время вы встретитесь. Помните, как в школе:
# "путник вышел из пункта А со скоростью..." - это и есть формализация
# задачи.

# После того как мы формализировали задачу и определились с логико-
# математической моделью, млжно начать переводить задачу на язык
# моддулей классов и методов.

# 2.3.1

# Расставте шаги в правильном порядке.

# --------------------------------------------------------------
# |      Шаг 1      |         Шаг 2         |       Шаг 3      |
# |  анализ задачи  |  формализация задачи  |  написание кода  |
# --------------------------------------------------------------

# 2.3.2

# Соотнесите.

# --------------------------------------------
# |     Архитектура :    |     "Костыли" :   |
# |------------------------------------------|
# |   Конкретные цели    |   Краткосрочные,  |
# |   и требования к     |   ситуационные    |
# |   результату.        |   цели.           |
# |------------------------------------------|
# |   Предполагаемая     |   Решение "здесь  |
# |   гибкость решения   |   и сейчас"       |
# |------------------------------------------|
# |   Сложность системы  |   Упрощенные      |
# |                      |   требования      |
# --------------------------------------------

# Работа над реализацией "жизненной" задачи.
# Метод Аббота

# Существует много подходов и к тому, как выполнять декомпозицию задачи,
# и к тому как потом сформировать программу из полученных частей. Самым
# простым и понятным подходом, возможно, даже наимным, является метод
# Аббота:

# 1. Напишите текст задачи. 

# 2. Выделите существительные и глаголы. Существительные будут
#      объектами. Глаголы - операциями еад объектами. 

# Разберём этот метод на примере.

# Возмём простую фразу: мама мыла Мишу.

# Видим, что у нас есть два объекта - мам и Миша, и одно лействие -
# мыла.

# Мама  и Мишу можно объединить в один класс "люди". А можно выделить
# два надкласса относительно процесса купания:

# 1. Тот, кто моет (мама).  Обозначим как класс Washer.

# 2. Тот, кого моет (Миша). Обозначим как класс Washable.

# В классе Washer укажем метод wash(). В классе Washable, допустим,
# выделим свойства dirtLevel (уровень загрязнений).

# Размышляя таким образом, можем придти к коду:

# класс тех, кого можно мыть
class Washable:
	def __init__(self) -> None:
		self.dirtLevel = 0

	def setDirtLevel(self, level):
		self.dirtLevel = level

	def setDirtLevel(self):
		retrun self.dirtLevel

# класс тех, кто может мыть
class Washer:
	def __init__(self) -> None
		pass

	def wash(self, washable):
		if washable.getDirtLevel() > 0:
			washable.getDirtLevel(0)

if __name__ == "__main__":
# программа, в которой Мама моет Мишу
	masha = Washable()
	masha.setDirtLevel(5)

	mom = Washr()
	mom.wash(masha)

	print(f'Mom washes Masha)

# Вопрос: А мы, что, используем здесь метод из другого класса?
#Ответ: Нет, в данном случае, мы не использем методы из другого класса, а
#просто проводим проверку. Эта проверка происходит у нас, когда мы
#принимаем экземпляр другого класса в этой строке: mom.wash(masha)
#washable является просто переменной. Вы можете назвать её как угодно и
#код всё равно будет рботать.

#Можно добавить реализма и внести классы:

# • Person (Личность).

# • WasherPerson (Личность, которая может мыть).

# • WashablePerson (Тот, кого моют).

# Также можем добавить дополнительные свойства и методы, создать
# небольшую иерархию классов или, даже с использованием тех же классов,
# переориентировать "маму" на мытье посуды, машины, окон и т.д.

# Метод Аббота может показать механическим, но формализация, анализ и
# распределение ответственности между различными частями программы -
# процесс творческий.

# Помните, что важны не сущности сами по себе, а именно ответственность,
# которую можно распределить между частями системы.
# Так, государству нужны глава, министры, судья и т.д. Все позиции и
# связанная с ними ответственность существуют как таковые, и нужно
# поставить на них людей с правильными "свойствами", которые смогут
# эффективно справляться с обязанностями. Так же и в ООП - нужно понять,
# из каких задач и подзадач слостоит проет, и распределить их между
# cоответствующими классами.

# Как измеряется качество архитектуры

# Качество архитектуры обычно измеряется по трём критериям:

# • эффективность;

# • гибкость;

# • масштабируемость.

# Эффективность означает соотношение цена/качество. Если наша
# программа или алгоритм выполняют свою задачу за приемлемое время,
# используя минимальное возможные для этого ресурсы, её можно назвать
# эффективной.

# Гибкость - способность к внесению изменений. Чем больше изменений
# 			 можно внести в программу за ограниченный объём времени, не разрушая
#			 при этом "то, что есть", тем она считается гибче.

# Например, вот код для решения квадратного уравнения:

import math

if __name__ == "__main__":
	a = int(input())
	b = int(input())
	c = int(input())

	d = b*b - 4*a*c
	if d > 0:
		x1 = (-b+math.sqrt(d))/(2*a)
		x2 = (-b-math.sqrt(d))/(2*a)

		print(f' x1 = {x1} x2 = {x2}')
	elif d < 0:
		print('no roots')
	else:
		x = -b/(2*a)
		print(f'x = {x}')

# Он не очень гибкий, т.к. ввод, вывод и расчёт смешаны в одном алгоритме.
# Но если мы отделим часть, связанную с расчётом в отдельнный метод, то
# выиграем в гибкости.

import math

def solveQuadraticEquation(a, b, c):
	result = []
	d = b*b - 4*a*c
	if d > 0:
		x1 = (-b+math.sqrt(d))/(2*a)
		x2 = (-b-math.sqrt(d))/(2*a)
		result = [x1, x2]
	elif d < 0:
		pass
	else:
		x = -b/(2*a)
		result = [x]

	return result

if __name__ == "__main__":
	a = int(input())
	b = int(input())
	c = int(input())

	solution = solveQuadraticEquation(a, b, c)
	print(solution)

# Мы выделили расчёт квадратного уравнения в отдельный метод и теперь
# можем присединить его к любой сиситеме ввода = вывода (считывание из
# файла - отправка по сети, приём параметров по сети - запись результата
# в файл и т.д.). Также можем вынести этот алгоритм в отдельный модуль или
# библиотеку, получая возможность вставить его в код там, где он
# потребуется.

# Маштабируемость - способность увеличивать пропускную
#					способность в зависимости от предоставляемых ресурсов.

# Например, если мы устанавливаем второй сервер, то ожидается, что
# эффективность нашей системы должна возрасти вдвое. Если второй сервер
# поставить нельзя, или эффективность при этом возрастает незначительно,
# значит система плохо масштабируема.

# Сценарий игры "Тир".

# Ещё немного примеров. Одна из основных проблем ООП, да и
# проектирование в целом, сосотоит в том, что мы должны чётко определить
# область ответственности каждого участника.

# Например, мы хотим написать игру - тир. В этой игре пользователю
# нужно поражать цели, которыми будут выступать геометрические фигуры.
# Пусть это будет квадраты.

# Напишем суенарий игры и проанализируем его по методу Аббота.

# Сценарий

# Игра начинается. Через определённые промежутки времени появляются
# фигуры случайного размера и цвета.

# Пользователь кликает на фигуру, "уничтожает" их и получает очки
# пропорциональные их размеру 9чем меньше фигура, тем больше очков).

# Анализ

# На основе сценария мы можем выделить следующие составляющие: цель,
# форма/фигуры, очки, поле, клик/выстрел, скорость появление и т.д.

# С формально - математической точки зрения, задача сводится к
# определению пересечения точки клика пользователя с фигурой (проще
# говоря, попал ли пользователь в квадрат или нет) и зачислении очков за
# фигуру.

# В реализации нам нужно будет отображать пользователя поле, но это
# боллле масштабная задача, поэтому сейчас мы опустим этот момент и
# сконцентрируемся на пересечениях. Давайте попробуем это сделать.

# Алгоритм программы будет переодически добавлять фигуры на поле, и
# должен будет опрелеять пересечения при клике пользователя. Если
# записать эти две операции в виде псевдокода, то получиться примерно
# следующее:

# операция "добавить цель" к общему списку отображаемых целей
addHitMark(mark):
		marks.append(mark)

# операция "поразить цель" в позиции pos
hit(pos):
	for mark in marks: # проходимся по списку целей
		if mark is hit: # и если есть пересечение
			remove mark # убиваем поражённую цель
		user score up # и начисляем очки

# Трудность состоит в том, что даже в током несложном действии, как
# определение пересечений, у нас есть выбор относительно того, кто будет
# ответственен за это. Мы можем сделать ответственным за это функцию hit
# таким образом, чтобы она получала форму цели и определяла пересечение
# с точки pos.

# 1
for mark in marks: # проходимся по списку целей
	mark_form = mark.getForm()
	if isPosIn(mark_form, pos):
		remove mark # убираем поражённую уель
			user score up # начисляем очки

# Или, наоборот, сделать ответственным за определение
# пересечения саму цель, предусмотрев метод, который может
# это сделать.

# 2
for mark in marks: # проходимся по списку целей
	if mark.isIn(pos):
		remove mark # убираем поражённую уель
			user score up # начисляем очки

# Сравнив два способа, придём к выводу, что пока форма
# цели - квадрат, эти способы более - менее эквивалентны.

# Если мы захотим расширить количество возможных форм и сложность их
# геометрию, то второй спосою будет более выигрышным, т.к. для первого
# способа нам нужно придумать, как пережставлять форму, получаемую
# методом mark.getForm(), и как искать с ней пересечение. Сделать это
# универсально - довольно трудно.

# Если выбирать второй способ, то нам не понадобиться настолько
# универсальная система, и мы сможем довольно легко и постепенно
# наращивать количество типов фигур в программе. Наша программа будет
# гибче, если бы мы выбрали первый способ. По крайне мере, в
# краткосрочной и среднесрочной перспективе.

# Давайте реализуем это в виде кода на Python:

# класс позиции элемента, хранящий значения х и у
class Pos:
	def __init__(self, x, y) -> None:
		self.x = x
		self.y = y

# абстракция - класс произвольной фигуры с полями позиция и цвет
class Figure:
	def __init__(self, pos) -> None:
		self.setPos(pos)
		self.setColor(0)

	def setPos(self, pos):
		self.pos = pos

	def getPos(self):
		return self.pos

	def setColor(self, color):
		self.color = color

	def getColor(self):
		return self.color

	# метод, который намекает на "форму" - при выполнении
	# метода класс возвращает True, если точка, переданная х и у,
	# лежит внутри фигуры и False в противном случае
	# поскольку класс Figure "не имеет" формы, то всегда
	# возвращает False

	def isIn(self, x, y)->bool:
		return False

# класс прямоугольника с шириной и высотой
class Square(Figure):
	def __init__(self, pos, w, h) -> None:
		super().__init__(pos)
		self.w = w
		self.h = h

# isIn в том случае возвращает True, если точка лежит между
# границами пряямоугольника
	def isIn(self, x, y) -> bool:
		_pos = super().getPos()
		if (_pos.x < x) and (  (_pos.x + self.w) > x) and (_pos.y < y) and (  (_pos.y + self.h) > y):
			return True
		return False

# Шахматы

# В примере с тиром мы обошлись "малой кровью", но иногда
# потенциальные объекты могут быть более тесно связаны между собой.
# Например если бы мы делали шахматы, и нам нужно было указать
# пользователя доступные ходы, скажем, коня. Понятно, что он ходит буквой
# "Г" :). К сожелению, компьютер не поймёт этой мнемонической фразы.
# Коню для определения возможных ходов нужно знать не только своё
# положение, но устройство доски - находится ли он с краю, в углу, по
# центру доски или где-либо ещё. Тут мы можем схитрить, позволив коню
# просто генирировать возможные ходы на основание свой текущий позиции,
# не проверяя их валидность (как будто он располагается на бесконечной
# доске), а коду более высокиго уровня уже предоставить возможность
# отсеять те ходы, которые лежат за пределами игрового поля.

# Второй способ - передавать в метод, возвращающие возможные ходы,
# также и список ограничений, которые должны учитываться при генерации
# вариантов.

# класс шахматной фигуры
class ChessFigure:
	def __init__(self) -> None:
		pass
	
	# метод, который должен возвращать список доступных для
	# фигуры ходов из указанной позиции
	
	def possibleMoves(self, pos, constrains = None):
		return []
			
# класс, который представляет фигуру коня
class ChessHorse(ChessFigure):
	def __init__(self) -> None:
		super().__init__()
		
# возможные ходы для коня из позиции pos
	def possibleMoves(self, pos, constrains = None):
		moves = []
		moves.append(  (pos.x + 2, pos.y + 1)  )
		moves.append(  (pos.x + 2, pos.y - 1)  )
		moves.append(  (pos.x - 2, pos.y + 1)  )
		moves.append(  (pos.x - 2, pos.y - 1)  )
		moves.append(  (pos.x + 1, pos.y + 2)  )
		moves.append(  (pos.x - 1, pos.y + 2)  )
		moves.append(  (pos.x + 1, pos.y - 2)  )
		moves.append(  (pos.x - 1, pos.y + 2)  )
		return moves
		
# Основной вывод, который можно сделать из этого примера:

# • Когда некая сущность может существовать «сама по себе», то
#   написание классов и оперирование такими объектами не
#   составляет труда. Примеры объектов: товар, персона,
#   поле таблицы и т.д., — всё, что можно представить как
#   набор неких свойств.

# • Когда объекты совместно участвуют в неком процессе
#   и разделяют между собой некий функционал, то ситуация
# 	обстоит сложнее — чем больше взаимосвязь объектов, тем
# 	труднее чётко выделить области ответственности разных
# 	объектов. Это значит, что классы таких объектов труднее
# 	реализовывать.

# Это не новая проблема, и подходы для более-менее типовых
# и часто встречающихся задач нашли свое отражение в принципах
# проектирования SOLID, KISS, YAGNI, DRY и др., а также в шаблонах
# проектирования.

# Мы не будем подробно касаться этих тем, т.к это тема для
# отдельного курса. Их и невозможно освоить, просто выслушав
# объяснения. Лучший способ понять эти принципы — практика.
# Примерно также как с завязыванием шнурков: довольно сложно
# объяснить словами (поскольку это процесс), но попробовав и
# потренировавшись, это становится очевидным.
		
# 2.3.3

# Укажите основные измерения качества архитектуры/кода:

# гибкость +++

# стабильность

# эффективность +++

# неподвижность

# масштабируемость +++

# верно
# Ответ
# Верно: Обычно выделяют 3 основных показателя: эффективность,
# гибкость и масштабируемость.
# Some problems have options such as save, reset, hints,
# or show answer. These options follow the Submit button.

# Задание 2.3.4

# Какие сущности (классы) можно предположить при переносе
# в код фразы «Жили у бабуси два весёлых гуся»?

# Бабуся +++

# Гуси +++

# Животные +++

# Владелец животных +++

# Веселые

# Живые существа +++

# верно
# Ответ
# Верно: Живые существа -> Животные -> Гуси.
# Живые существа -> Владелец животных -> Бабуся.
# Some problems have options such as save, reset,
# hints, or show answer. These options follow
# the Submit button.

# В этом юните мы рассмотрели, как можно подходить
# к анализу и построению архитектуры приложения,
# узнали о методе Аббота и потренировались на
# небольших шуточных примерах.

# А сейчас немного отдохните, попейте чаёк.
# В следующем юните мы продолжим разбираться
# на более сложных примерах →