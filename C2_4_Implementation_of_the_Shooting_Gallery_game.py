#С2.4. Реализация игры "Тир"
                                                                                                                               
#Мы не будем рассматривать всю градацию возможных примеров от
#простых к сложным, т.е. это заняло бы слишком много времени. Сразу 
#перейдём к довольно сложному примеру - делаем наш тир.

#Если мы рассмотрим концептуальную схему любой игры, то она выглядит
#примерно так:

#                                      ________                                                                         
#                                    /                 \                                                                        
#                 ┌–———–|   Графика   |‒‒‒‒‒‒‒‒‒┐              
#                  |                  \________ /                   |                                                     
#                  |                      ↑        ↑                      |                                                     
#         ____↓____              |          |              ____↓___                                               
#        /                 \ ———┘        └––––—/                 \                                              
#        |   Физика   |—————————→|   Логика    |                                           
#        \________ /←—————————\________ /                                             
                                                                                                                                      #Физика (как физический движок) может присутствовать, а может и нет, или
#присутствовать в зачаточном виде в зависимости от типа игры. то же 
#относится и к логике, но графика в играх присутствует всегда.

#Основная сложность состоит в том, что с одной стороны, с точки зрения 
#архитектуры и разработки мы должны стремиться к тому, чтобы все эти
#части были максимально самобытны и независимы. С другой - это
#довольно тружно сделать, т.к. все части сильно завязаны на графику и
#взаимодействие с пользователем.

#Написать игру без сильного разделения этих частей можно, что было бы
#проще, но тогда наш проект станет более неподвижным (в 
#противоположность гибкости). Мы не сможем улучшать эти системы
#независимо друг от друга, например, графику от логики и/или наоборот.
#Если же мы преуспеваем в разделении этих систем без урона для 
#финкционала, то получаетм возможность большего манёвра в разработке и 
#улучшении функционала.

#Реализуя наш тир, мы увидем, что оскществить такое разделение не так
#просто, но возможно. Это потребует некоторых усилий. Именно поэтому 
#такое  ПО, как игровые движки (UnrealEngine, Unity, Godot и др.), выделилось
#в отдельную область. Раньше каждый разработчик сам разрабатывал свою
#графическую систему.
                                                                                       
#Мы уже начали разрабатывать костяк логической системы тира, определив
#классы Pos, Figure и Square и реализовали метод isIn, который
#определял, содержится ли точка внутри фигуры или нет.

#Чотбы завершить логический этап, связанный с свмими целями, нам нужен
#дополнительный класс. Он бы представлял именно цепь, а не
#геометрический примитив, т.к. в отличии от формы, цвета и всего прочего
#у цели в гашеё интерпретации должна быть стоимость в очках.

#Сделаем это, определив HitMark и  SquareHitMark.

#класс цели, включающий параметр стоимости
class HitMark:
	def __init__(self, cost) -> None:
		self.setCost(cost)
		
	def setCost(self, cost):
		sekf.cost = cost
		
	def getCost(self):
		return self.cost
		
#класс "прямоугольной" цели, наследуемый от класса
#прямоугольника и класса цели, который вклучает как
#форму, так и стоимость

class SquareHitMark(Square, HitMark):
	def __init__(self, pos,w, h, cost) -> None:
		super().__init__(pos, w, h)
		HitMark.setCost(sekf, cost)
		
#Схема классов этой части системы будет выглядить так:

#   __________                                                                                                         
#   |                   |                                                                                                          
#   |  "inreface"  |                                                                                                          
#   |     Figure    |                                                                                                          
#   |_________|                                                                                                          
#            ↑                                                                                                                  
#             |                                                                           
#   _____|_____                   __________                                        
#   |                   |                   |                   |                                        
#   |    Square    |                    |   HitMark   |                                
#   |_________|                    |_________|
#            ↑                                     ↑                                                                              
#            └‒‒‒‒‒‒‒‒ ┬‒‒‒‒‒‒‒‒┘                                 
#                   _______|______                                                                                   
#                  |                           |                                                                                    
#                  |  SquareHitMark  |                                                                                     
#                  |_____________| 


#Теперь при помощи этих классов нам нужно завершить логическую
#составляющую игры, в которой должно происходить следующе события:

# • Через определённые промежутки времени будут появляться новые
#    цели, случаного размера, цвета и стоимости.

# • Пользователь будет пытаться поразить цель, кликая на неё.

#Первый пункт мы можем выполнять и без графики, добавляя новые цели в
#некий список. Второй - потребует от нас взаимодействия с 
#пользователем, а стало быть, пользовательский интерфейс в какм-то
#виде.

#Что же нам делать? Как сделать так, чтобы с одной стороны, логическая
#подсистема была независима от графической, а с другой - могла
#присоединять её к себе и даже менять одну на другую?

#Самый простой спосою, к которому обычно прибегают - создание системы
#обмена сообщениями между частями системы. В виде схемы это можно
#представить так:

#                                           сообщение                                           
#   _____________           ____         ____           _____________   
#   |                         |          |        |        |        |          |                         |    
#   |  Графическая  |‒‒‒‒‒|____|‒‒‒‒|____|‒‒‒→|    Логическая   |     
#   |      система      |          ____         ____           |        игра          |     
#   |____________ |←‒‒‒|        |‒‒‒‒|        |‒‒‒‒ |____________ |     
#                                       |____|        |____| 

#GameEvent

#Мы будем обмениваться событиями напрямую. Для этого создадим
#отдельный класс сообщений и назовём его GameEvent. Он будет служить
#"коробочкой", в которую будут передоваться сообщения между графикой и 
#логикой. У класса GameEvent будут поля тип и данные, а также несколько
#общих констант, определяющих тип сообщения.

#класс унутриигрового сообщенпия
class GameEvent:

#пустое событие
	Event_None = 0
#событие таймера
	Event_Tick = 1
#событие "выстрела" по цели
	Event_Hit = 2
	
	def __init__(self, type, data) -> None:
		self.type = type
		self.data = data
		
	def getType(self):
		return self.type
		
	def getData(self):
		retrun self.data
		
#GameLogic

#Теперь, когда у нас есть класс событий, мф можем определить класс
#игровой логики GameLogic. Он будет включать всю внутриигровую логику
#нашей игры, которая сосотит всего из двух действий:

# • нахождение пересечения клика пользователя с фигурой;

# • подсчёт очков.

#В реальной ситуации это было бы скорее отдельная подсистема (система
#связанных между собой классов), а не класс. У нас относительно простой
#случай, поэтому подсистема уместилась в рамках одного класса.

#класс игровой логики
class GameLogic:
	def __init__(self, w, h) -> None:
	#ширина игрового поля
		self.gameboard_width = w
	#высота игрового поля
		self.gameboard_height = h
	#активные цели на доске
		self.marks = []
	#поражение цели
		self.hitMarks = []
	#получение очки
		self.score = 0

	#метод обработки сообщений, которые подходят к игровой логике
	def processEvent(self, event):
	#если событие таймер, то добавляем ещё одну цель к списку активных целей
		if event.type == GameEvent.Event_Tick:
			#на случайной позиции в пределах игровой доски
			markPandPos = Pos(rnd.randint(20,self.gameboard_width-20),rnd.randint(20,self.gameboard_height-20))
			#случайного размера от 10 до 20
			markSize = rnd.randint(10, 20)
			#стоимость цели обратно пропорциональна размеру
			markCost = 30 - markSize
			#случайный цвет цели в формате  RGB
			narkColor = (rnd.randint(0,255),rnd.randint(0,255),rnd.randint(0,255))
			mark = SquareHitMark(markRandPos,markSize,markSize,markCost)
			mark.setColor(markColor)
	#добавляем цель на доску
			self.addHitMark(mark)
	#если сообщение "выстрил в цель", тоо обрабатываем эту ситуацию
	#используя позицию pos, переданную от интерфейса
		if event.type == GameEvent.Event_Hit:
			self.hit(event.data)
	
#метод добавить цель на "логическую" доску
	def addHitMark(self, mark):
		self.amrks.append(mark)

#метод поразить цель на "логической" доске
	def hit(self, pos):
#перебирать все цели, и методы isIn возвращать True
#добавляем стоимость цели к счёту и перемещаем её из списка 
#активных целей в поражённые
		for markIndex in range(len(self.marks)):
			mark - self.marks[markIndex]
			if mark.isIn(pos.x, pos.y):
				self.score += mark.getCost(0
				self.mark.pop(markIndex)
				self.hitMarks.append(mark)
				break
				
#метод возвращает все вктивные цели на доске
	def getBoard(self):
		return self.marks
	#метод возвращает текущиё счёт
	sef getScore(self):
		return self.score
		
#Отлично! Игровая логика готова.

#2.4.1

#Для чего используется обмен сообщениями между разными частями
#программы?

#чтобы сделать программу более сложной

#чтобы разные части программы были более независимыми +++

#чтобы замедлить выполнение программы

#потому что это общая практика 
		
		
#Теперь, чтобы проверить логику, нам нужно  прикрутить графику - GUI. В
#принцепе мы могли бы сделать какой-то простенький минималистичный
#текстовый вариант с заданием координат цели вручную или при помощи
#ASCII графики, но это будет не так наглядно, поэтому оставим этот вариант
#для домашнего задания.

#Чтобы увидеть плоды нашего труда, сделаем графику при помощи
#библиотеки pygame.

#Изучение pygame выходит за рамки этого курса. Мы взяли эту
#юиюлиотеку только для того, чтобы довести нашё задачу до конца и 
#сделать это красиво.

#Установим pygame, выполнив команду:

pip install pygame

#Внимани! pygame не работает с Python 3.11. Нужно откатиться на 3ю10б
#иначе может возникнуть ошибка при установке.

#Мы выразим графическую подсистему нашей игры в виде отдельного
#класса PyGameGui, так же как в случае с логикой.

#классу, реализующий графичекую подсистему игры
class PyGameGui:
	def __init__(self, w, h, logic) -> None:
#ширина окна
		self.main_w = w
#высота она
		self.main_h = h
#окно pygame
		self.screen = pegame.display.set_mode([self.main_w, self.main_h])
#логика игры в виде внутреннего объекта
		self.logic = logic
#шрифт для отображения счёта на экране
		self.font = pygame.font.SysFont('Consolas', 30)
		
#метод, который запучкае игру
	def run(self):
		running = True
#устанавливаем таймер pygame на 1 сек
		pygame.time.set_timer(pygame.USEREVENT + GameEvent.Event_Tick, 1000)
#создаём бесконечный цикл обработки сообщений от пользователя
		while running:
			#если пользователь закрыл окно, то завершаем обработку
			#собфтий и закрываеи игру иначе обработываем сообщение
			for event in pygame.event.get():
				if event.type == pygema.QUIT:
					running = False
				else:
					self.processEvent(event)
			#выполняем отрисовку
			self.draw()
			
#метод обработки сообзений от интерфейса
	def pocessEvent(self, event):
#если событие таймера, то переделываем событие pygame в
#событие нашей игры GameEvent
		if (event.type >= pygame.USEREVENT) and (event.type < pygame.NUMEVENTS):
			myevent = GameEvent()
			myevent.type = event.type - pygame.USEREVENT
			self.logic.processEvent(myevent)
#если событие клик мышкой, то передаём позицию клика в сообщение Hit
		if event.type == pygame.MOUSEBUTTONDOWN:
			pupos = event.pos
			myevent = GameEvent(GameEvent.Event_Hit, Pos(pypos[0], pypos[1]))
			self.logic.processEvent(myevent)
			
#метод отрисовки доски
	def draw(self):
		#звполняем фон
		self.screen.fill((255, 255, 255))
		
#получаем все активные цели на доске и отрисовываем их в
#виде прямоугольника соответствующего цвета
		marks = self.logic.getBoard()
		for mark in marks:
			pygame.draw.rect(self.screen, mark.getColor(), pygame.Rect(mark.getPos().x,mark.getPos().y, mark.getWidth(), mark.getHeight()))
			
#получаем текущие очки
		score = self.logic.getScore()
#отображаем счёт на окне
		self.screen.blit(self.font.render(f'score:{score}', True, (0, 0, 0)), (32, 48))
		
		pygame.display.flip()
		
#После этого можем соединить все части вместе и запустить игру 

if __name__ == "__main__":
	pygame.init(0
	width = 800 
	height = 600
	gui = PyGameGui(width, height, GameLogic(width, height))
	gui.run()
	pygame.quit()
	
#2.4.1
					
#Предлогаем вам самостотятельно выполнить данное задание. В конце
#модуля у вас будет возможность посмотреть скринкаст и ознакомиться
#с эталонным решением.

#Создайте для нашего тира другой графический интерфейс - консольный
#Напишите класс ConsoleGameGui, который в качестве способа
#взаимодействия с пользователем будет использовать консоль: 

# • все фигуры, которые есть на доске, выводятся списком с координатами;

# • ввод координат осуществляется также через консоль;

# • таймеры и время не используются;

# • Event_tick полылается на очередном цикле вывода координат фигур
#    консоль и запроса координат у пользователя.

#Ответ

#наш новый класс, который представляет графику и способ взаимодействия 
#с пользователем
class ConsoleGameGui::
#инициализация точно такаже, как с pygame, только теперь он
#нам не нужен
	def __init__(selfm w, h, logic) -> None:
		self.w = w
		self.h = h 
		self.logic = logic
		
#тут будет цил обработки сообщений и взаимодействия с пользователем
	def run(self):
		running = True
		while running:
#сначала посылаем сообщение Event_Tick, чтобы была
#сгенерированна цель
			self.processEvent(GameEvent.Event_Tick, None))
			
#отрисовываем то, что сейчас должно быть на доске
			self.draw()
			
#запрашиваем команды у пользователя
			print('-----------------------')
			print('0. exit')
			print('1. hit target')
			cmd = int(input())

#значение пустого события по умолчанию
			event = GameEvent(GameEvent.Event_None, None)
#если команда 0 - идём на выход
			if cmd == 0:
				running = False
				continue
#если команда 1 запрашиваем координаты
			if cmd == 1:
				x = int(input('input X:  '))				
				y = int(input('input Y:  '))
				event = GameEvent(GameEvent.Event_Hit, Pos(x, y))
				
#отрабатываем событие
			self.processEvent(event)
			
#в отличии от варианта с pygame тут никакой логики не, но
#мы всё равно остановили этот метод, чтобы повторять ту же 
#структуру класса
	def processEvent(self, event):
		self.Logic.processEvent(event)

#метод отображения содержимого доски
	def draw(self):
#выводим текущий счёт
		score = self.logic.getScore()
		print('--------------------------')
		print(f'Your score: {score}')
		
#выводим текущие цели
		print('Aims: ')
		marks = self.logic.getBoard()
		for index, mark in enumerate(mark):
			print(f'aim{index}[x = {mark.getPos().x}, y = {mark.getPos().y}, w = {mark.getWidth()}, h = {mark.getHeight()}]: {mark.getCost()}')
			
#---------------------------------------------------------------------------------
if __name__ == "main":
	width  = 800
	height = 600
	gui = ConsoleGameGui(width, height,GameLogic(width, height))
	gui.run()
	
	