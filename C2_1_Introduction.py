# С2.1 Введение

#В этом модуле продолжим изучать ООП и:

#* пожробно разберёмся с тем, как разбить большую задачу на
#   подзадачи и реализовать их в виже методов и классов;

#* поговорим о проектировании классов;

#* познакомимся с декораторами @staticmethod, @classmethod, 
#   @property и другие удобные фишки;

#* начнём разбираться с исключениями и тем, как их использовать;

#* подготовимся к итоговому заданию и выполним его.

#Важно отметить, что принцип проектирования инженерных сисстем, к
#которым относиться программное обеспечение, п тпежн ООП как одна
#из частных концепций, невозможно освоить быстро - так же, как 
#начертив пару квадратов, невозможно стать архитектором. 
#Проектирование и архитектура, в каком-то смысле, это работа с
#задачей "в целом" требует такого же цельного восприятия, которому
#мы и пытаемся научиться.

#Не переживайте, если сразу что-то не получаеться или покажется не совсем
#ясным и однозначным. Если вы продолжите писать программы, пользуясь
#материалами модулей, то со временим вам станет ясно, как писать
#программы "лучше всего".

#А пока, перед тем как приступить к новому материалу, выполним несколько
#задач на повторение.

#2.1.1

#Какое назначение у метода __init__?

#Этот метод-конструктор, используемый для первоначальной
#инициализации создоваемого объекта. +++

#Специальный метод, который нужен для того, чтобы наш класс был
#зарегистрирован в Python.

#Метод, используемый при удалении объекта.

#Метод, инициализирующий глобальные переменные.

#2.1.2

#В чём ошибка придённого кода?

class Human:
	def __init__(self) -> None:
		pass
		
	def set_age(self, a):
		self.age = a
		
	def git_age(self):
		rutern self.age
		
if __name__ == "__main__":
	h = Human()
	print(h.get_age())
	
#Конструктор без параметров, в котором не инициализируются
#внутренние поле класса. +++
#Верно: 
#Поскольку в конструкторе не создаётся и не инициализируется поле age ,
#при вызове этого метода без предварительного вызова метода set_age
#приведёт к ошибке AttributeError.

#Неверное название класса

#pass в реализации метода.

#self указан во всех методах.

#2.1.3

#Что будет выведенно на экране в результате работы кода ?

class A:
	def getVal(self):
		return 5
		
class B(A):
	def getVal(self):
		return super().getVal()*2
		
class C(B):
	def getVal(self):
		return super().getVal()*2*2
		
class D(A):
	def getVal(self):
		return super().getVal()*2*2
		
if __name__ == "__main__":
	a = C()
	print(a.getVal())
	
#5

#10

#20
		
#40 +++
#Верно:
#Из объекта класса С вызов С.getVal() будет раскрываться как
#В.getVal()*2*2, в котором вызов В..getVal() будет раскрываться как
#А.getVal()*2, а А.getVal() как 5. Итог получается: 5*2*2*2 = 40

#4

#64
